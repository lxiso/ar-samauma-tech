<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0">
        <title>AR Experience</title>
        <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
        <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
        </head>

    <body style="margin: 0; overflow: hidden;">
        <a-scene embedded arjs emitevents="true" renderer="antialias: true; logarithmicDepthBuffer: true;">
            <a-entity camera></a-entity>

            <a-marker id="markerOne" type="hiro" emitevents="true">
                <a-entity id="objOne" gltf-model="url(testDummy.glb)" animation-mixer autoplay="true" scale="0.5 0.5 0.5"></a-entity>
            </a-marker>

            <a-marker id="markerTwo" type="pattern" url="/markers/pattern.patt" emitevents="true">
                <a-entity id="objTwo" gltf-model="url(testDummy.glb)" animation-mixer autoplay="true" scale="0.5 0.5 0.5"></a-entity>
            </a-marker>

            <script>
                document.addEventListener('DOMContentLoaded', function () {
                    const objOne = document.querySelector('#objOne');
                    const objTwo = document.querySelector('#objTwo');
                    const markerOne = document.querySelector('#markerOne');
                    const markerTwo = document.querySelector('#markerTwo');
            
                    const idleAnim = 'clip:idle; crossFadeDuration: 0.5';
                    const wavingAnim = 'clip:waving; crossFadeDuration: 1';
            
                    // Function to interpolate rotation using slerp
                    function interpolateRotation(object, targetPosition, deltaTime) {
                        // Get the object's current quaternion
                        const currentQuaternion = object.object3D.quaternion.clone();
            
                        // Create a temporary object3D to calculate the target rotation
                        const tempObject = new THREE.Object3D();
                        tempObject.position.copy(object.object3D.position);
                        tempObject.lookAt(targetPosition);
            
                        // Get the target quaternion from the temporary object
                        const targetQuaternion = tempObject.quaternion.clone();
            
                        // Interpolate between the current and target quaternions
                        currentQuaternion.slerp(targetQuaternion, deltaTime);
            
                        // Apply the interpolated quaternion back to the object
                        object.object3D.quaternion.copy(currentQuaternion);
                    }
            
                    // Update function to align rotations smoothly
                    function update() {
                        // Check marker visibility
                        const markerOneVisible = markerOne.object3D.visible;
                        const markerTwoVisible = markerTwo.object3D.visible;
            
                        if (markerOneVisible && markerTwoVisible) {
                            // Get world positions of the objects
                            const objOnePos = new THREE.Vector3().setFromMatrixPosition(objOne.object3D.matrixWorld);
                            const objTwoPos = new THREE.Vector3().setFromMatrixPosition(objTwo.object3D.matrixWorld);
            
                            // Debugging: Print positions to console
                            console.log('Object One Position:', objOnePos);
                            console.log('Object Two Position:', objTwoPos);
            
                            // Update animations
                            objOne.setAttribute('animation-mixer', wavingAnim);
                            objTwo.setAttribute('animation-mixer', wavingAnim);
            
                            // Interpolate rotations
                            interpolateRotation(objOne, objTwoPos, 0.1); // Adjust deltaTime for smoothness
                            interpolateRotation(objTwo, objOnePos, 0.1);
                        } else {
                            // Switch to idle animations
                            objOne.setAttribute('animation-mixer', idleAnim);
                            objTwo.setAttribute('animation-mixer', idleAnim);
            
                            // Debugging: Log visibility states
                            console.log('Marker One Visible:', markerOneVisible);
                            console.log('Marker Two Visible:', markerTwoVisible);
                        }
                    }
            
                    // Call update at regular intervals
                    setInterval(update, 50);
                });
            </script>            
        </a-scene>
    </body>
</html>